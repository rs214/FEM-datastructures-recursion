//1)
//Implement factorial.
//factorial(5) => 5*4*3*2*1 => 120


//2)
// Write a function that outputs the nth Fibonnaci number. A number in this sequence is found by adding up the two numbers before it.
// Fibonnaci's sequence:
// input    0 1 2 3 4 5 6  7  8  9 ...
// output   0 1 1 2 3 5 8 13 21 34 ...
// What is the time complexity? Can you think of optimizing your solution? (Hint: look up dynamic programming)


//3)
/*
Implement a function that flattens a nested array.
flatten([1,[2],[3, [[4]]]]);
=> [1,2,3,4]
*/

//4)
/*
Write a function that takes two numbers and returns the greatest common divisor.
*/

//5)
/*
Implement a function that takes in a two-dimensional array of colors that represents a screen, a point in the array, and a color. The function will change the original color of the point to the new color and will fill the surrounding area with the original color in the same fashion.
*/


//6)
/*
Version 1:
Given the size of a grid (X rows and Y columns), write a function that returns the number of possible paths one can take starting at the top left of the grid and ending at the bottom right, assuming you can only move to the right and down.
Version 2:
Now, imagine that the you can move up, down, left, or right but cannot visit a spot that has already been visited. How many unique paths can the you take?
Hint: it may be useful to create a grid class and use it to keep track of the state as the you traverses the grid. What useful methods can you put on your grid class? Can you write an implementation that only uses a single grid?
*/


//7)
/*
Implement a function that will reverse a string recursively.
reverse('abcdefg')
=> 'gfedcba'
*/

//8)
/*
Write a function that takes a string and returns all permutations of the string. Ensure that there are no duplicates in the output.
*/